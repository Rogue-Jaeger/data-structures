// https://practice.geeksforgeeks.org/problems/diagonal-traversal-of-binary-tree/1



// its a wrong solution but see how the queue and map are integrated the test case that failed it was

254
0 1 L 0 2 R  1 3 L 1 4 R  2 5 L 2 6 R  3 7 L 3 8 R  4 9 L 4 10 R  5 11 L 5 12 R  6 13 L 6 14 R  7 15 L 7 16 R  8 17 L 8 18 R  9 19 L 9 20 R  10 21 L 10 22 R  11 23 L 11 24 R  12 25 L 12 26 R  13 27 L 13 28 R  14 29 L 14 30 R  15 31 L 15 32 R  16 33 L 16 34 R  17 35 L 17 36 R  18 37 L 18 38 R  19 39 L 19 40 R  20 41 L 20 42 R  21 43 L 21 44 R  22 45 L 22 46 R  23 47 L 23 48 R  24 49 L 24 50 R  25 51 L 25 52 R  26 53 L 26 54 R  27 55 L 27 56 R  28 57 L 28 58 R  29 59 L 29 60 R  30 61 L 30 62 R  31 63 L 31 64 R  32 65 L 32 66 R  33 67 L 33 68 R  34 69 L 34 70 R  35 71 L 35 72 R  36 73 L 36 74 R  37 75 L 37 76 R  38 77 L 38 78 R  39 79 L 39 80 R  40 81 L 40 82 R  41 83 L 41 84 R  42 85 L 42 86 R  43 87 L 43 88 R  44 89 L 44 90 R  45 91 L 45 92 R  46 93 L 46 94 R  47 95 L 47 96 R  48 97 L 48 98 R  49 99 L 49 100 R  50 101 L 50 102 R  51 103 L 51 104 R  52 105 L 52 106 R  53 107 L 53 108 R  54 109 L 54 110 R  55 111 L 55 112 R  56 113 L 56 114 R  57 115 L 57 116 R  58 117 L 58 118 R  59 119 L 59 120 R  60 121 L 60 122 R  61 123 L 61 124 R  62 125 L 62 126 R  63 127 L 63 128 R  64 129 L 64 130 R  65 131 L 65 132 R  66 133 L 66 134 R  67 135 L 67 136 R  68 137 L 68 138 R  69 139 L 69 140 R  70 141 L 70 142 R  71 143 L 71 144 R  72 145 L 72 146 R  73 147 L 73 148 R  74 149 L 74 150 R  75 151 L 75 152 R  76 153 L 76 154 R  77 155 L 77 156 R  78 157 L 78 158 R  79 159 L 79 160 R  80 161 L 80 162 R  81 163 L 81 164 R  82 165 L 82 166 R  83 167 L 83 168 R  84 169 L 84 170 R  85 171 L 85 172 R  86 173 L 86 174 R  87 175 L 87 176 R  88 177 L 88 178 R  89 179 L 89 180 R  90 181 L 90 182 R  91 183 L 91 184 R  92 185 L 92 186 R  93 187 L 93 188 R  94 189 L 94 190 R  95 191 L 95 192 R  96 193 L 96 194 R  97 195 L 97 196 R  98 197 L 98 198 R  99 199 L 99 200 R  100 201 L 100 202 R  101 203 L 101 204 R  102 205 L 102 206 R  103 207 L 103 208 R  104 209 L 104 210 R  105 211 L 105 212 R  106 213 L 106 214 R  107 215 L 107 216 R  108 217 L 108 218 R  109 219 L 109 220 R  110 221 L 110 222 R  111 223 L 111 224 R  112 225 L 112 226 R  113 227 L 113 228 R  114 229 L 114 230 R  115 231 L 115 232 R  116 233 L 116 234 R  117 235 L 117 236 R  118 237 L 118 238 R  119 239 L 119 240 R  120 241 L 120 242 R  121 243 L 121 244 R  122 245 L 122 246 R  123 247 L 123 248 R  124 249 L 124 250 R  125 251 L 125 252 R  126 253 L 126 254 R


// output was

0 0 0
1 -1 1
3 -2 2
7 -3 3
15 -4 4
31 -5 5
63 -6 6
127 -7 7
128 -5 7
64 -4 6
129 -5 7
130 -3 7
32 -3 5
65 -4 6
131 -5 7
132 -3 7
66 -2 6
133 -3 7
134 -1 7
16 -2 4
33 -3 5
67 -4 6
135 -5 7
136 -3 7
68 -2 6
137 -3 7
138 -1 7
34 -1 5
69 -2 6
139 -3 7
140 -1 7
70 0 6
141 -1 7
142 1 7
8 -1 3
17 -2 4
35 -3 5
71 -4 6
143 -5 7
144 -3 7
72 -2 6
145 -3 7
146 -1 7
36 -1 5
73 -2 6
147 -3 7
148 -1 7
74 0 6
149 -1 7
150 1 7
18 0 4
37 -1 5
75 -2 6
151 -3 7
152 -1 7
76 0 6
153 -1 7
154 1 7
38 1 5
77 0 6
155 -1 7
156 1 7
78 2 6
157 1 7
158 3 7
4 0 2
9 -1 3
19 -2 4
39 -3 5
79 -4 6
159 -5 7
160 -3 7
80 -2 6
161 -3 7
162 -1 7
40 -1 5
81 -2 6
163 -3 7
164 -1 7
82 0 6
165 -1 7
166 1 7
20 0 4
41 -1 5
83 -2 6
167 -3 7
168 -1 7
84 0 6
169 -1 7
170 1 7
42 1 5
85 0 6
171 -1 7
172 1 7
86 2 6
173 1 7
174 3 7
10 1 3
21 0 4
43 -1 5
87 -2 6
175 -3 7
176 -1 7
88 0 6
177 -1 7
178 1 7
44 1 5
89 0 6
179 -1 7
180 1 7
90 2 6
181 1 7
182 3 7
22 2 4
45 1 5
91 0 6
183 -1 7
184 1 7
92 2 6
185 1 7
186 3 7
46 3 5
93 2 6
187 1 7
188 3 7
94 4 6
189 3 7
190 5 7
2 1 1
5 0 2
11 -1 3
23 -2 4
47 -3 5
95 -4 6
191 -5 7
192 -3 7
96 -2 6
193 -3 7
194 -1 7
48 -1 5
97 -2 6
195 -3 7
196 -1 7
98 0 6
197 -1 7
198 1 7
24 0 4
49 -1 5
99 -2 6
199 -3 7
200 -1 7
100 0 6
201 -1 7
202 1 7
50 1 5
101 0 6
203 -1 7
204 1 7
102 2 6
205 1 7
206 3 7
12 1 3
25 0 4
51 -1 5
103 -2 6
207 -3 7
208 -1 7
104 0 6
209 -1 7
210 1 7
52 1 5
105 0 6
211 -1 7
212 1 7
106 2 6
213 1 7
214 3 7
26 2 4
53 1 5
107 0 6
215 -1 7
216 1 7
108 2 6
217 1 7
218 3 7
54 3 5
109 2 6
219 1 7
220 3 7
110 4 6
221 3 7
222 5 7
6 2 2
13 1 3
27 0 4
55 -1 5
111 -2 6
223 -3 7
224 -1 7
112 0 6
225 -1 7
226 1 7
56 1 5
113 0 6
227 -1 7
228 1 7
114 2 6
229 1 7
230 3 7
28 2 4
57 1 5
115 0 6
231 -1 7
232 1 7
116 2 6
233 1 7
234 3 7
58 3 5
117 2 6
235 1 7
236 3 7
118 4 6
237 3 7
238 5 7
14 3 3
29 2 4
59 1 5
119 0 6
239 -1 7
240 1 7
120 2 6
241 1 7
242 3 7
60 3 5
121 2 6
243 1 7
244 3 7
122 4 6
245 3 7
246 5 7
30 4 4
61 3 5
123 2 6
247 1 7
248 3 7
124 4 6
249 3 7
250 5 7
62 5 5
125 4 6
251 3 7
252 5 7
126 6 6
253 5 7
254 7 7
7 142
0 142 150 154 78 86 90 158 174 182 186 94 110 118 122 190 222 238 246 250 126 254 1 70 74 38 22 46 30 62 3 134 138 18 156 157 166 170 92 93 102 106 188 189 206 214 218 124 125 252 253 7 66 34 76 77 42 26 54 15 130 16 140 141 4 172 173 108 109 220 221 230 234 31 64 65 67 71 79 95 32 68 69 8 82 10 6 58 63 128 129 131 135 143 159 191 132 133 17 146 20 178 114 236 237 127 33 72 73 75 36 84 85 44 28 14 136 137 139 19 148 149 21 180 181 116 117 242 35 80 81 83 87 37 88 89 91 45 29 60 144 145 147 151 23 152 153 155 5 184 185 187 120 121 123 244 245 39 96 97 99 103 111 9 98 2 61 160 161 163 167 175 162 24 198 202 248 249 251 47 40 100 101 50 192 193 195 199 207 223 164 165 25 204 205 41 104 105 107 12 168 169 171 27 210 43 112 113 115 119 52 176 177 179 183 212 213 11 53 194 216 217 219 48 13 196 197 226 49 56 200 201 203 228 229 51 57 208 209 211 215 232 233 235 55 59 224 225 227 231 239 240 241 243 247




void solve(Node * root , map <int , queue <  pair< int , int > > > &m , int h , int v ){
    if(!root) return;

    cout << root->data <<" " << h <<" " << v << endl;
    m[h].push( make_pair( v , root->data ) );

    solve(root->left , m , h-1 , v+1 );
    solve(root->right , m , h+1 , v+1 );

    return;
}



void diagonalPrint(Node *root){
    if(!root) return;

    map <int , queue <  pair< int , int > > > m;

    solve(root , m , 0 , 0);

    cout << m[1].front().first <<" "<< m[1].front().second << endl;

    int size = m.size();
    int zero = 0;

    for(auto i : m){
        if(i.first == 0) break;
        zero++;
    }

    int maxsize = size - zero - 1;

    map <int , int> m2;

    for(int i = 0 ; m2.size() != size ; i--){
        if(i<-zero) i = -zero;

        int j = i;

        while( j <= maxsize ){
            if( m[j].size() == 0 ) m2[j]++;
            else{
                int val = m[j].front().first;
                while( m[j].size() != 0 && m[j].front().first == val ){
                    cout << m[j].front().second << " ";
                    m[j].pop();
                }
            }
            j++;
        }
    }

    return;


}
